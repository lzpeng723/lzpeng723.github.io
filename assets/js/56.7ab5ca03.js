(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{706:function(n,e,a){"use strict";a.r(e);var r=a(10),s=Object(r.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("本文对比了当前主流的包管理工具"),a("code",[n._v("npm")]),n._v("、"),a("code",[n._v("yarn")]),n._v("、"),a("code",[n._v("pnpm")]),n._v("之间的区别，并提出了合适的使用建议，以下为译文：")]),n._v(" "),a("h2",{attrs:{id:"npm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#npm"}},[n._v("#")]),n._v(" NPM")]),n._v(" "),a("p",[n._v("npm是Node.js能够如此成功的主要原因之一。npm团队做了很多的工作，以确保npm保持向后兼容，并在不同的环境中保持一致。")]),n._v(" "),a("p",[n._v("npm是围绕着 "),a("a",{attrs:{href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer"}},[n._v("语义版本控制（semver）"),a("OutboundLink")],1),n._v(" 的思想而设计的，下面是从他们的网站摘抄过来的：")]),n._v(" "),a("p",[a("em",[n._v("给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号:")])]),n._v(" "),a("ul",[a("li",[a("em",[n._v("主版本号： 当API发生改变，并与之前的版本不兼容的时候")])]),n._v(" "),a("li",[a("em",[n._v("次版本号： 当增加了功能，但是向后兼容的时候")])]),n._v(" "),a("li",[a("em",[n._v("补丁版本号： 当做了向后兼容的缺陷修复的时候")])])]),n._v(" "),a("p",[n._v("npm使用一个名为"),a("code",[n._v("package.json")]),n._v("的文件，用户可以通过"),a("code",[n._v("npm install --save")]),n._v("命令把项目里所有的依赖项保存在这个文件里。")]),n._v(" "),a("p",[n._v("例如，运行"),a("code",[n._v("npm install --save lodash")]),n._v("会将以下几行添加到"),a("code",[n._v("package.json")]),n._v("文件中。")]),n._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token property"}},[n._v('"dependencies"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[n._v('"lodash"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[n._v(":")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[n._v('"^4.17.4"')]),n._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br")])]),a("p",[n._v("请注意，在版本号lodash之前有个^字符。这个字符告诉npm，安装主版本等于4的任意一个版本即可。所以如果我现在运行npm进行安装，npm将安装lodash的主版本为4的最新版，可能是 lodash@4.25.5（@是npm约定用来确定包名的指定版本的）。你可以在此处查看所有支持的字符："),a("a",{attrs:{href:"https://docs.npmjs.com/about-semantic-versioning",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://docs.npmjs.com/about-semantic-versioning"),a("OutboundLink")],1),n._v(" 。")]),n._v(" "),a("p",[n._v("理论上，次版本号的变化并不会影响向后兼容性。因此，安装最新版的依赖库应该是能正常工作的，而且能引入自4.17.4版本以后的重要错误和安全方面的修复。")]),n._v(" "),a("p",[n._v("但是，另一方面，即使不同的开发人员使用了相同的"),a("code",[n._v("package.json")]),n._v("文件，在他们自己的机器上也可能会安装同一个库的不同种版本，这样就会存在潜在的难以调试的错误和“在我的电脑上…”的情形。")]),n._v(" "),a("p",[n._v("大多数npm库都严重依赖于其他npm库，这会导致嵌套依赖关系，并增加无法匹配相应版本的几率。")]),n._v(" "),a("p",[n._v("虽然可以通过"),a("code",[n._v("npm config set save-exact true")]),n._v("命令关闭在版本号前面使用的默认行为，但这个只会影响顶级依赖关系。由于每个依赖的库都有自己的"),a("code",[n._v("package.json")]),n._v("文件，而在它们自己的依赖关系前面可能会有符号，所以无法通过package.json文件为嵌套依赖的内容提供保证。")]),n._v(" "),a("p",[n._v("为了解决这个问题，npm提供了"),a("a",{attrs:{href:"https://docs.npmjs.com/cli/shrinkwrap",target:"_blank",rel:"noopener noreferrer"}},[n._v("shrinkwrap"),a("OutboundLink")],1),n._v(" 命令。此命令将生成一个"),a("code",[n._v("npm-shrinkwrap.json")]),n._v("文件，为所有库和所有嵌套依赖的库记录确切的版本。")]),n._v(" "),a("p",[n._v("然而，即使存在"),a("code",[n._v("npm-shrinkwrap.json")]),n._v("这个文件，npm也只会锁定库的版本，而不是库的内容。即便npm现在也能阻止用户多次重复发布库的同一版本，但是npm管理员仍然具有强制更新某些库的权力。")]),n._v(" "),a("p",[n._v("这是引用自 shrinkwrap 文档的内容：")]),n._v(" "),a("p",[a("em",[n._v("如果你希望锁定包中的特定字节，比如是为了保证能正确地重新部署或构建，那么你应该在源代码控制中检查依赖关系，或者采取一些其他的机制来校验内容，而不是靠校验版本。")])]),n._v(" "),a("p",[n._v("npm 2会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，那么依赖树将如下所示：")]),n._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("node_modules\n- package-A\n-- node_modules\n--- package-B\n----- node_modules\n------ package-C\n-------- some-really-really-really-long-file-name-in-package-c.js\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br")])]),a("p",[n._v("这个结构可能会很长。这对于基于Unix的操作系统来说只不过是一个小烦恼，但对于Windows来说却是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名。")]),n._v(" "),a("p",[n._v("npm 3采用了扁平依赖关系树来解决这个问题，所以我们的3个项目结构现在看起来如下所示：")]),n._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("node_modules\n- package-A\n- package-B\n- package-C\n-- some-file-name-in-package-c.js\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br")])]),a("p",[n._v("这样，一个原来很长的文件路径名就从"),a("code",[n._v("./node_modules/package-A/node_modules/package-B/node-modules/some-file-name-in-package-c.js")]),n._v("变成了"),a("code",[n._v("./node_modules/some-file-name-in-package-c.js")]),n._v("。")]),n._v(" "),a("p",[n._v("你可以在"),a("a",{attrs:{href:"https://docs.npmjs.com/how-npm-works/npm3",target:"_blank",rel:"noopener noreferrer"}},[n._v("这里"),a("OutboundLink")],1),n._v(" 阅读到更多有关NPM 3依赖解析的工作原理。")]),n._v(" "),a("p",[n._v("这种方法的缺点是，npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是"),a("a",{attrs:{href:"https://link.zhihu.com/?target=https://github.com/npm/npm/issues/8826",target:"_blank",rel:"noopener noreferrer"}},[n._v("npm安装速度慢的一个很重要的原因"),a("OutboundLink")],1),n._v(" 。")]),n._v(" "),a("p",[n._v("由于我没有详细了解npm的变化，所以我想当然的以为每次运行"),a("code",[n._v("npm install")]),n._v("命令时，NPM都得从互联网上下载所有内容。")]),n._v(" "),a("p",[n._v("但是，我错了，npm是有本地缓存的，它保存了已经下载的每个版本的压缩包。本地缓存的内容可以通过"),a("code",[n._v("npm cache ls")]),n._v("命令进行查看。本地缓存的设计有助于减少安装时间。")]),n._v(" "),a("p",[n._v("总而言之，npm是一个成熟、稳定、并且有趣的包管理器。")]),n._v(" "),a("h2",{attrs:{id:"yarn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[n._v("#")]),n._v(" Yarn")]),n._v(" "),a("p",[n._v("Yarn发布于2016年10月，并在Github上迅速拥有了2.4万个Star。而npm只有1.2万个Star。这个项目由一些高级开发人员维护，包括了Sebastian McKenzie（"),a("a",{attrs:{href:"https://babeljs.io/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Babel.js"),a("OutboundLink")],1),n._v(" ）和Yehuda Katz（"),a("a",{attrs:{href:"https://www.emberjs.com/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Ember.js"),a("OutboundLink")],1),n._v(" 、"),a("a",{attrs:{href:"https://www.rust-lang.org/en-US/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Rust"),a("OutboundLink")],1),n._v(" 、"),a("a",{attrs:{href:"http://bundler.io/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Bundler"),a("OutboundLink")],1),n._v(" 等）。")]),n._v(" "),a("p",[n._v("从我搜集到的情况来看，Yarn一开始的主要目标是解决上一节中描述的由于语义版本控制而导致的npm安装的不确定性问题。虽然可以使用"),a("code",[n._v("npm shrinkwrap")]),n._v("来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。")]),n._v(" "),a("p",[n._v("Yarn采取了不同的做法。每个yarn安装都会生成一个类似"),a("code",[n._v("于npm-shrinkwrap.json")]),n._v("的"),a("code",[n._v("yarn.lock")]),n._v("文件，而且它是默认创建的。除了常规信息之外，"),a("code",[n._v("yarn.lock")]),n._v("文件还包含要安装的内容的校验和，以确保使用的库的版本相同。")]),n._v(" "),a("p",[n._v("由于yarn是崭新的经过重新设计的npm客户端，它能让开发人员并行化处理所有必须的操作，并添加了一些其他改进，这使得运行速度得到了显著的提升，整个安装时间也变得更少。我估计，速度提升是yarn受欢迎的主要原因。")]),n._v(" "),a("p",[n._v("像npm一样，yarn使用本地缓存。与npm不同的是，yarn无需互联网连接就能安装本地缓存的依赖项，它提供了离线模式。这个功能在2012年的npm项目中就被提出来过，但一直没有实现。")]),n._v(" "),a("p",[n._v("yarn还提供了一些其他改进，例如，它允许合并项目中使用到的所有的包的许可证，这一点让人很高兴。")]),n._v(" "),a("p",[n._v("一个有趣的事情是，yarn文档的态度开始针对npm发生改变，因为yarn项目变得流行起来。")]),n._v(" "),a("p",[n._v("最开始的yarn公告是这么介绍yarn的安装的：")]),n._v(" "),a("p",[n._v("*最简单的入门方法是运行：")]),n._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[n._v("npm")]),n._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("install")]),n._v(" -g "),a("span",{pre:!0,attrs:{class:"token function"}},[n._v("yarn")]),n._v(" \nyarn*\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br")])]),a("p",[n._v("现在的yarn安装页面是这么说的：")]),n._v(" "),a("p",[a("em",[n._v("注意：通常情况下不建议通过npm进行安装。npm安装是非确定性的，程序包没有签名，并且npm除了做了基本的SHA1哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。")])]),n._v(" "),a("p",[a("em",[n._v("基于这些原因，强烈建议你通过最适合于你的操作系统的安装方法来安装yarn。")])]),n._v(" "),a("p",[n._v("以这种速度发展下去的话，如果yarn要宣布他们自己的registry，让开发者慢慢淘汰npm的话，我们一点都不会感到惊讶。")]),n._v(" "),a("p",[n._v("看起来似乎要感谢yarn，npm终于意识到他们需要更加关注一些大家强烈要求的问题了。当我在审核我之前提到的强烈要求的“离线”功能时，我注意到这个需求正在被积极地修复之中。")]),n._v(" "),a("h2",{attrs:{id:"pnpm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[n._v("#")]),n._v(" pnpm")]),n._v(" "),a("p",[n._v("正如我所提到的，在"),a("a",{attrs:{href:"https://github.com/pnpm/pnpm",target:"_blank",rel:"noopener noreferrer"}},[n._v("pnpm"),a("OutboundLink")],1),n._v(" 的作者Zoltan Kochan发表了“"),a("a",{attrs:{href:"https://www.kochan.io/nodejs/why-should-we-use-pnpm.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("为什么要用pnpm？"),a("OutboundLink")],1),n._v(" ”之后，我才知道pnpm。")]),n._v(" "),a("p",[a("strong",[n._v("但是")])]),n._v(" "),a("p",[n._v("我想指出的是，pnpm运行起来非常的快，甚至"),a("a",{attrs:{href:"https://github.com/pnpm/node-package-manager-benchmark",target:"_blank",rel:"noopener noreferrer"}},[n._v("超过了npm和yarn"),a("OutboundLink")],1),n._v(" 。")]),n._v(" "),a("p",[n._v("为什么这么快呢？ 因为它采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一。")]),n._v(" "),a("p",[n._v("使用链接并不容易，会带来一堆问题需要考虑。")]),n._v(" "),a("p",[n._v("正如Sebastian在"),a("a",{attrs:{href:"https://twitter.com/sebmck/status/855553631680069637",target:"_blank",rel:"noopener noreferrer"}},[n._v("Twitter"),a("OutboundLink")],1),n._v("上指出的那样，他最初是打算在yarn中使用符号链接的，但是由于其他"),a("a",{attrs:{href:"https://github.com/yarnpkg/yarn/issues/1761%23issuecomment-259706202",target:"_blank",rel:"noopener noreferrer"}},[n._v("一些原因"),a("OutboundLink")],1),n._v("放弃了它。")]),n._v(" "),a("p",[n._v("同时，正如在Github上拥有2000多个Star那样，pnpm能够为许多人所用。")]),n._v(" "),a("p",[n._v("此外，截至2017年3月，它继承了yarn的所有优点，包括离线模式和确定性安装。")]),n._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),a("p",[n._v("我认为yarn和pnpm的开发人员做了一个惊人的工作。我个人喜欢的是确定性安装，因为我喜欢控制，我不喜欢惊喜。")]),n._v(" "),a("p",[n._v("无论这场竞争的结果是什么，我很感谢yarn在npm的脚下点了一把火，提供了另外一个选择。")]),n._v(" "),a("p",[n._v("我确信yarn是一个更安全的选择，但是pnpm可能是一些测试用例的更好的选择。例如，它可以在运行大量集成测试并希望尽可能快地安装依赖关系的中小型团队中发挥作用。")]),n._v(" "),a("p",[n._v("最后，我认为，npm仍然提供了一个非常有用的解决方案，支持大量的测试用例。大多数开发人员使用原始npm客户端仍然可以做得很好。")])])}),[],!1,null,null,null);e.default=s.exports}}]);